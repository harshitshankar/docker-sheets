docker --version — check Docker client version.

docker compose version — check compose plugin.

docker images — list local images.

docker ps — list running containers.

docker ps -a — list all containers (running + stopped).

docker logs -f <container> — stream container logs (great for Spring Boot startup logs).

docker exec -it <container> /bin/sh or /bin/bash — open a shell inside container (if image has shell).

docker inspect <container> — JSON metadata (useful for networking/port info).

docker rm -f <container> — remove/force-stop container.

docker rmi <image> — remove images.

docker compose up --build — build and start all services in compose.

docker compose logs -f app — stream logs for service named app in compose file.

docker stats — runtime resource usage for containers.

docker ps
This shows container IDs and names.

Access the container’s shell:

bash
docker exec -it <container_id_or_name> sh
or, if the container uses bash:

bash
docker exec -it <container_id_or_name> bash
Navigate inside the container: Once inside, use Linux commands like:

bash
ls
cd /app  # or wherever you copied files
cat filename.txt



Today

🛠️ docker build -t automation-demo .
The . at the end refers to the build context, which is typically the current directory.

Docker uses this context to find the Dockerfile and any files referenced inside it (like those you might copy into the image).

So this command means: 👉 “Build a Docker image named automation-demo using the Dockerfile and files in the current directory.”

📦 COPY . . in a Dockerfile
This command has two parts:

The first . means: copy everything from the current directory on your machine (the build context).

The second . means: place it in the root directory of the image (inside the container).

So it’s saying: 👉 “Copy all files from my local folder into the root of the container’s filesystem.”

⚠️ A quick tip
Using COPY . . can be risky if your local directory has sensitive files (like .env, .git, or credentials). It’s often better to use a .dockerignore file to exclude unnecessary or sensitive files from being copied.

Want to see a cleaner Dockerfile example or explore .dockerignore next?

so you use . at end of docker right so current dierectory means inmy local project folder where I ran
Exactly! 🎯 When you run:

bash
docker build -t automation-demo .
that final . means “use the current directory as the build context.” So yes, it refers to the local project folder where you’re running the command—the one you're currently inside in your terminal or command prompt.

Here's how it works:
Suppose you're in a folder like this:

Code
/Users/yourname/projects/my-app/
and you run the docker build command there, Docker will:

Look for a Dockerfile in that folder

Package up all the files in that folder (except those ignored via .dockerignore)

Use them as the context for building the image

So, the . is just a shorthand for “this folder right here.”

Let me know if you want to walk through a full Dockerfile example using this!

ok but dutring copy . . it copies things let say fro mm my local c drive and it puts it in my conatiner path how to accsss my container path i think is docker ps and docker exec-it "docker icontainer id or docjker name I beliwve
You're absolutely on the right track! Let me walk you through it clearly so you can confidently explore your container’s file system after using COPY . . in your Dockerfile.

🧳 What COPY . . Does Recap:
It copies everything from your local build context (e.g., your current folder on C drive) into the working directory inside the container.

If you didn’t specify a WORKDIR in your Dockerfile, it defaults to / (the root directory).

So, if your Dockerfile has:

Dockerfile
COPY . .
and no WORKDIR, then your files go into / inside the container. If you had:

Dockerfile
WORKDIR /app
COPY . .
then your files go into /app.

🔍 How to Access the Container’s File System
Here’s how to get inside your running container and explore:

List running containers:

bash
docker ps
This shows container IDs and names.

Access the container’s shell:

bash
docker exec -it <container_id_or_name> sh
or, if the container uses bash:

bash
docker exec -it <container_id_or_name> bash
Navigate inside the container: Once inside, use Linux commands like:

bash
ls
cd /app  # or wherever you copied files
cat filename.txt
🧼 Bonus Tip: Clean Up After Yourself
When you're done:

bash
exit
